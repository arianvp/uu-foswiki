%META:TOPICINFO{author="AtzeDijkstra" comment="reprev" date="1468491628" format="1.1" reprev="43" version="44"}%
%META:TOPICPARENT{name="AttributeGrammarSystem"}%
%TOC%

---+ UU AG System User Manual

---++ Getting Started

---+++ Installing the UUAG system

The easy way: =cabal install uuagc=

Otherwise:
   * Have a recent GHC compiler on your system
   * Download the UULIB Haskell package
      * From [[Download][the download page]]
      * From [[http://hackage.haskell.org/cgi-bin/hackage-scripts/package/uulib][Hackage]]
   * Unzip and use Cabal to compile and install the UULIB package:
      <verbatim>
> cd <uulib source directory>
> ghc --make Setup.hs -o setup -package Cabal
> ./setup configure
> ./setup build
> ./setup install
      </verbatim>
   * Download a source distribution of the UUAG system:
      * From [[Download][the download page]]
      * From [[http://hackage.haskell.org/cgi-bin/hackage-scripts/package/uuagc][Hackage]]
   * Unzip and use Cabal to compile and install the UUAG package:
      <verbatim>
> cd <uuagc source directory>
> ghc --make Setup.hs -o setup -package Cabal
> ./setup configure
> ./setup build
> ./setup install
      </verbatim>

---+++ Running the UUAG system

We assume that UUAG compiler is installed on your system.
If you run the compiler without arguments it will show you a short help message, and a list of options.

<verbatim>
> uuagc
Usage info:
  uuagc options file ...

List of options:
  -m                        generate default module header
           --module[=name]  generate module header, specify module name
  -d       --data           generate data type definitions
  ...</verbatim>

In this user manual all the compiler switches and language features are introduced and explained with
examples.

It must be noted that there are two different syntaxes that can be used: the "old" AG syntax and the Haskell like syntax. The latter is preferred for clarity and hence used in this manual. However, in the current version of the compiler the old syntax is default, so to compile the examples the =-H= (or =--haskellsyntax=) option must be used to explicitly enable the Haskell like syntax.

---+++ Example 1: Calculate the sum of a tree of integers

Her is a complete UUAG program.
It defines binary trees of integers, and how to compute their sum.
It also defines a test tree containing some test data, and computes their sum.
<verbatim>
data Tree
   | Node  left  :: Tree
           right :: Tree
   | Tip   value :: Int

attr Tree
   syn sum :: Int

sem Tree
  | Node  lhs.sum  =  @left.sum + @right.sum
  | Tip   lhs.sum  =  @value

{
main :: IO ()
main = print (show test)

testTree :: Tree
testTree = Node (Tip 1) (Node (Tip 2) (Tip 3))

test :: Int
test = sem_Tree testTree
}
-- output of the program will be "6"</verbatim>

The program consists of some UUAG declarations, introduced by the keywords
=data=, =attr=, and =sem=.
It also contains a plain Haskell part, which is enclosed in braces.
All text in braces is
not touched by the preprocessor and passed unchanged to the Haskell compiler.

With the =data= declaration we define the syntax of our datatype.
A =data= declaration is quite similar to a Haskall =data= declaration, but:
   * each field has a name
   * all alternatives are preceded with a "|" (even the first one)

With an =attr= declaration we specify attributes, that is the values
we want to calculate in our tree walk. We can specify top-down, threaded,
and bottom-up attributes, with the constructs =inh=, =chn= and =syn= constructs
respectively. Currently only a bottom-up attribute is specified.

With a =sem= declaration we specify the semantics.
For each constructor we have an assignment that states how the
sum for the left hand side (=lhs=) can be calculated from the fields
and/or the attributes of the right hand side.
A field can be referred to by an =@= and the field name (as in =@value= ),
an attribute by selecting from a field with a "dot" notation (as in =@left.sum= ).
These items can be combined by any Haskell expression (in this case just a =+= ).

In the Haskell part
we define an example tree structure by using the type =Tree=
and the constructors =Node= and =Tip= introduced by the =data= declaration.

A function =sem_Tree= is generated by the preprocessor.
It can be used to determine the semantics of our example structure.

The program can be preprocessed, compiled an run by:

<verbatim>
uuagc -dcfH Example1.ag
ghc Example1.hs
./Example1</verbatim>

---+++ Example 2: Multiple attributes, and wrappers

The second example program defines four attributes
(the sum and maximum of a tree, its front, and a copy of it)
and as a test selects one of them to print (the front).
<verbatim>
data Tree
   | Node  left  :: Tree
           right :: Tree
   | Tip   value :: Int

attr Tree
   syn sum   :: Int
   syn max   :: Int
   syn front :: {[Int]}
   syn copy  :: Tree

sem Tree
  | Tip   lhs.max  =  @value
          lhs.sum  =  @value
  | Node  lhs.sum  =  @left.sum   +   @right.sum
             .max  =  @left.max `max` @right.max
          
sem Tree
  | Node  lhs.front = @left.front ++ @right.front
          lhs.copy  = Node @left.copy @right.copy
  | Tip   lhs.front = [ @value ]
          lhs.copy  = Tip @value

{
main :: IO ()
main = print (show result)

testTree :: Tree
testTree = Node (Tip 1) (Node (Tip 2) (Tip 3))

test :: T_Tree
test = sem_Tree testTree

result :: [Int]
result = front_Syn_Tree (wrap_Tree test Inh_Tree)
}
-- output of the program will be "[1,2,3]"</verbatim>

In the =attr= declaration, we define four bottom-up, or "synthesized" attributes.
As of yet, we still don't have top-down, or "inherited" attributes.
Types of attributes can be any Haskell type, including the
ones generated when preprocessing this this file, but if they are
not a simple name they must be escaped by curly braces.

In =sem= declarations we define the values for all four attributes
for both constructors.
For each constructor we can give multiple assignments at once,
but we can also distribute assignments in separate =sem= declarations.
Constructors and their assignments may appear in any order.
If, for a particular constructor, we have multiple assignments sharing
the same target field, we may omit the field name (as is done with =.max= in the =Node= semantics).

In the Haskell part,
because we declared four synthesized attributes, calling =sem_Tree= now returns a quadruple.
The order of the elements of this quadruple is unspecified.
To be able to use it in signatures, the type of the full quadruple is available
as =T_Tree= (as an effect of the =-s= option).

As we are interested in a particular element of the quadruple, we run the
preprocessor with =-w= option. This will generate a function =wrap_Tree=, which takes:
   * the semantics of the tree (which is the quadruple of unknown order)
   * an additional argument for initializing inherited attributes (currently just the constant =Inh_Tree=)
and returns
   * the four synthesized attributes again, but now as a value of datatype with named fields
From the result of =wrap_Tree=, we can select the desired attribute by name.

Because we need type signatures and wrapper functions to be generated in this example,
we add options =-s= and =-w= to the original ones (=-d= for generating datatypes, =-c= and =-f= for
generating the "catamorphism" function and the individual semantic functions, and =-H= for Haskell like syntax).
So the program can be preprocessed, compiled an run by:

<verbatim>
uuagc -dcfswH Example2.ag
ghc Example2.hs
./Example2</verbatim>

---+++ Example 3: Inherited attributes

The third example program defines an attribute
that will be a transformed version of the tree. It has the same shape as
the original tree, but different values: all values are
replaced by a single constant.
Again, it is tested on an example tree, in which all values are replaced by 37.
<verbatim>
data Tree
   | Node  left  :: Tree
           right :: Tree
   | Tip   value :: Int

deriving Tree : Show

attr Tree
   inh replacement :: Int
   syn transformed :: Tree

sem Tree
  | Node  lhs.transformed   = Node @left.transformed @right.transformed
          left.replacement  = @lhs.replacement
          right.replacement = @lhs.replacement
  | Tip   lhs.transformed   = Tip @lhs.replacement


{
main :: IO ()
main = print (show result)

testTree :: Tree
testTree = Node (Tip 1) (Node (Tip 2) (Tip 3))

test :: T_Tree
test = sem_Tree testTree

result :: Tree
result = transformed_Syn_Tree (wrap_Tree test Inh_Tree{replacement_Inh_Tree=37} )
}
-- output of the program will be "Node (Tip 37) (Node (Tip 37) (Tip 37))"</verbatim>

As we will use the Haskell =show= function on the =Tree= datatype in the main program,
we need to have Haskell =deriving Show= for the =Tree= datatype.
In the preprocessor language, this is requested in a separate =deriving= declaration.

In an =attr= declaration,
we declare a synthesized attribute _transformed_, that will be
a transformed version of the tree. It has the same shape as
the original tree, but different values: all values are
replaced by a single constant.
The value to use as a replacement is information that flows
top-down through the tree.
For this, we declare an *inherited* attribute _replacement_.

In the =sem= declaration,
the definition of synthesized attribute _transformed_ is like
the _copy_ attribute from Example2, except that at a =Tip=,
instead of =@value=, the _replacement_ value is inserted.

For the inherited attribute _replacement_, the role of the
two sides of the assignments are reversed: we may now *use*
the value of =@lhs.replacement= at the right side of the equation,
but we must *define* the values for the _left_ and _right_ children.

The inherited attribute needs to be initialized at the top of the tree.
This is done in the Haskell part as the second argument to =wrap_Tree=.
That argument is a datastructure with named fields for all inherited attributes.
The notation with the braces in the definition of =result= is the (not so well-known) Haskell notation for
initializing such datastructure values.

---+++ Example 4: Multiple datatypes, the self pseudotype, auto-generated rules

This example is a re-work of Example 3, where the value "37" is fixed
internally during the tree walk, rather than passing it when calling the tree walk.

For this, we need a non-recursive wrapper-type =Root= around
the recursive type =Tree=.
<verbatim>
data Root
   | Root  tree  :: Tree

data Tree
   | Node  left  :: Tree
           right :: Tree
   | Tip   value :: Int

deriving Root Tree : Show

attr Root Tree
   syn transformed :: self

attr Tree
   inh replacement :: Int

sem Tree
  | Tip   lhs.transformed = Tip @lhs.replacement
  
sem Root
  | Root  tree.replacement = 37

{
main :: IO ()
main = print (show result)

testTree :: Tree
testTree = Node (Tip 1) (Node (Tip 2) (Tip 3))

testRoot :: Root
testRoot = Root testTree

test :: T_Root
test = sem_Root testRoot

result :: Root
result = transformed_Syn_Root (wrap_Root test Inh_Root)
}
-- output of the program will be "Root (Node (Tip 37) (Node (Tip 37) (Tip 37)))"</verbatim>

We can declare attributes for multiple datatypes in a single =attr= declaration.
Here we do so for the synthesized attribute _transformed_.
For this particular attribute there would be a problem, because
a transformed Root has type Root, and a transformed Tree has type Tree.
But we can summarize that by using the pseudotype =self=, and still
declare the attribute _transformed_ in a single declaration.

The inherited attribute _replacement_ is only needed in the Tree datatype,
so it is declared in a separate =attr= declaration.

An additional effect of using the pseudotype =self= is that semantic rules
are defined implicitly, that as a default generate a copy of the datastructure.
So we don't have to specify explicitly that a transformed Node consists of
the Node constructor applied to the transformed versions of its children,
and that a transformed Root is Root re-applied to the transformed version of its content tree.

The only semantic rule we *do* need to write, is where we disagree with the
default behaviour: at a Tip, we don't want a copy, but insert the replacement value.

The non-recursive wrapper type Root is a good place to initialize
inherited attributes. So in another =sem= declaration the value of _replacement_
is set to be 37.
The Haskell part is thus freed of the responsibility to initialize the inherited attribute:
the non-recursive wrapper type =Root= not even has one.
So the call to start the tree walk is as simple as in Example 2.

Another rule =sem= that you might expect is:

<verbatim>
sem Tree
  | Node  left.replacement  = @lhs.replacement
          right.replacement = @lhs.replacement</verbatim>

This is not needed though, because rules that copy inherited attributes
unchanged to the children are inserted automatically when nothing other is specified.
This defaulting mechanism is known as (one of the forms of) the *copy rule*.

---+++ Example 5: Two-pass traversals

This example is another variation on Example 4, where again
we generate a tree of the same shape as the original one,
with values replaced by a constant.
The constant however is not taken to be 37, but
the sum of all values in the original tree.

Appearantly, this would require a two-pass traversal of the tree:
one pass that determines the sum, and another one to construct
the copy-with-replaced-values.
But the program does not really look very different than Example 4:
<verbatim>
data Root
   | Root  tree  :: Tree

data Tree
   | Node  left  :: Tree
           right :: Tree
   | Tip   value :: Int

set Every = Root Tree

deriving Every : Show

attr Every
   syn transformed :: self

attr Tree
   inh replacement :: Int
   syn sum         :: Int

sem Tree
  | Tip   lhs.transformed = Tip @lhs.replacement
          lhs.sum         = @value
  | Node  lhs.sum         = @left.sum + @right.sum

sem Root
  | Root  tree.replacement = @tree.sum

{
main :: IO ()
main = print (show result)

testRoot :: Root
testRoot = Root (Node (Tip 1) (Node (Tip 2) (Tip 3)))

test :: T_Root
test = sem_Root testRoot

result :: Root
result = transformed_Syn_Root (wrap_Root test Inh_Root)
}
-- output of the program will be "Node (Tip 6) (Node (Tip 6) (Tip 6))"</verbatim>

As an added convenience, we introduce the =set= declaration in this example.
A =set= declaration is a way to abbreviate sets of datatypes.
The name can be used instead of an explicit enumeration of the set
in other (=deriving=, =attr= and =sem=) declarations.

In the =attr= declarations,
we re-introduce synthesized attribute _sum_ here for datatype Tree (see Example1).
Notice that Tree has two synthesized attributes:
   * =sum: Int= (which is obviously declared)
   * =transformed: Tree= (because =Tree= is part of the =Every= set, and =self= is instantiated to =Tree=)

In the =sem= declaration for =Root= in Example4 we initialized the replacement value with 37.
But nothing prevents us from letting the replacement value depend
on other synthesized attributes, such as _sum_.

In effect, we now have defined a two-pass tree traversal.
In the first pass, the _sum_ of all values is calculated.
In the second pass, the _transformed_ tree is build, using the _sum_ as the _replacement_ value.
combined, we have synthesized a tree of the same shape as the original,
where every value is replaced by the sum of all values.
The nice thing is that you need hardly be aware that this is actually a
two-pass traversal.
You can freely use synthesized attributes to define inherited attributes,
that may in turn be needed to define other synthesized attributes.
Your only concern should only be that the dependency is not circular,
but whether one, two, or six passes are necessary is automatically determined.

---++ Building AG files with Cabal

The UUAG system consists of the preprocessor =uuagc= and a Cabal plugin =uuagc-cabal=. The UUAG preprocessor takes several UUAG files (.ag) and produces a Haskell file (.hs). Instead of invoking the preprocessor manually as we described above, we can also let Cabal take care of that through the Cabal plugin. Take the following steps.

In the =Setup.hs=, add an import declaration for the cabal plugin and use the special user-hook:
<verbatim>
import Distribution.Simple (defaultMainWithHooks)
import Distribution.Simple.UUAGC (uuagcLibUserHook)
import UU.UUAGC (uuagc)

main = defaultMainWithHooks (uuagcLibUserHook uuagc)</verbatim>

Furthermore, add in the same directory a file called =uuagc_options=, which must specify for each AG file, with what features the corresponding Haskell file is to be build:
<verbatim>
file : "src/MyModule.ag"
options : data, catas, semfuns, signatures, pretty, rename, module "MyModule", wrappers</verbatim>

Cabal then keeps track of dependencies between files, and ensures that files are rebuild after changes.

---++ Language Constructs

This section gives an overview of the UUAG language.
The  following sections show the syntax of each construct by example.
A complete reference in EBNF of the UUAG language can be found in the appendix.

---+++ data declaration

A ==data== declares a nonterminal, and a number of productions for a nonterminal.
Each production is labelled with a constructor name.
Constructors must be unique within a nonterminal,
but (unlike in Haskell) the same constructor name is allowed in other nonterminals.
Giving multiple ==data== declarations for the same nonterminal is allowed, provided that the constructor
names in the declarations do not clash.
The fields of each production all have a name and a type.
The type can be a nonterminal or a Haskell type. All fields of the same constructor must have different names.

Valid ==data== declarations:

<verbatim>
data Tree | Bin  left :: Tree  right :: Tree 
          | Leaf value :: Int

data Decl | Fun  name :: String  args :: {[String]}  body :: Expr</verbatim>

Several abbreviations exist for ==data== declarations. Fields with the same type can be declared
by listing their names separated by commas. Also the field name can be left out,
in which case the name is defaulted to the type name with the first letter converted to lowercase.
It is only allowed to leave out the field name if the type is an uppercase type identifier.
You also need to make sure that the default name does not clash with the name of another field.
The following example show correct abbreviations:

<verbatim>
data Tree | Bin  left,right :: Tree   -- two fields with the same type
          | Leaf               Int    -- field name implicitly is 'int'</verbatim>

The following ==data== declaration is wrong:

<verbatim>
data Tree | Bin Tree Tree    -- two nameless fields have the same type, so would have the same name
          | Leaf {(Int,Int)} -- type of nameless field is not a simple name, so no name can be deduced for it</verbatim>

Polymorphic abstract syntax is allowed by adding type variables to ==data== declarations. The variables are required to be lower-case identifiers. The type variables are only usable somewhere inside a Haskell type (hence the curly braces). Use parentheses around nonterminals to be able to pass a list of Haskell types to the nonterminal. The following example shows a binary tree storing values of type _a_ or _b_ depending on the depth of the leaf:
<verbatim>
data Eq {a}, Show {b} => Tree a b
  | Bin left,right :: (Tree {b} {a})
  | Leaf value :: {a}</verbatim>

If a nonterminal is defined using several ==data== declarations, the list of type variables is the concatenation of the type variables of the individual declarations in the order of appearance.

These ==data== declarations define the structure of the Abstract Syntax Tree. An AST can be constructed for a nonterminal ==D== (data type) using alternatives ==C== (constructor) in Haskell by applying some arguments to the constructor ==D_C==, returning a value of type ==D== when all arguments are applied. Alternatively, a deforested AST (the denotation of the AST) can be constructed by using the functions ==sem_D_C== instead of the constructor ==D_C==, returning a value of type ==T_D== when all arguments are applied.

---+++ attr declaration

An ==attr== declaration declares attributes for one or more nonterminals.
Each attribute is inherited, chained, or synthesized and has a name and a type.
A chained attribute is just an abbreviation for an attribute that is both inherited and synthesized.
The names of all inherited attributes declared by ==attr== statements must be different.
The same holds for synthesized attributes.

Valid ==attr== declarations are:

<verbatim>
attr Tree
   inh depth   :: Int
   chn minimum :: Int
   syn out     :: {[Bool]}
attr Tree
   inh count :: Int
   syn count :: Int
attr Decl inh environment :: {[(String,Type)]}
attr Decl syn code :: Instructions</verbatim>

In attribute declarations the abbreviations for fields in a ==data== declaration are not allowed, so all attributes must have an explicit name and they can not be grouped.

A ==use== clause can be added to the declaration of a synthesized or chained attribute,
to trigger a special kind of copy rule.
The first expression must be an operator, and the second expression is a default value for the attribute.
For example:

<verbatim>
data Tree
   | Bin left,right :: Tree
   | Leaf value :: Int
attr Tree
   syn value use {+} {0} :: Int -- compute sum of values</verbatim>

An attribute can be declared to be of type ==self==.
The type ==self== is a placeholder for the type of the nonterminal for which the attribute is declared.
For example:

<verbatim>
attr Tree Expr
   syn copy :: self</verbatim>

The ==attr== statement above declares an attribute _copy_ of type _Tree_ for nonterminal _Tree_,
and an attribute _copy_ of type _Expr_ for nonterminal _Expr_.
Declaring a synthesized attribute of type ==self== triggers a special copy-rule,
that constructs a copy of the tree.

To refer to type variables of polymorphic nonterminals in the types of attributes, use the name of the type variable prefixed with an _@_. Type variables only need to be prefixed when they occur in the type of an attribute. The type of the attribute has to be a Haskell type (in curly braces). For example, to declare a synthesized attribute that is a list of all the values in the tree:

<verbatim>
data Tree a | Bin left,right :: (Tree {a})
            | Leaf value :: {a}
attr Tree
   syn elements :: {[@a]}</verbatim>

Attribute declarations can also be given in ==data== or ==sem== statements after the name of the nonterminal.
For example:

<verbatim>
data Tree | Bin left,right :: Tree
          | Leaf Int
attr Tree
   syn min :: Int</verbatim>

can be combined into:

<verbatim>
data Tree syn min :: Int
   | Bin left,right :: Tree
   | Leaf Int</verbatim>

---+++ sem

In a ==sem== construct one can specify semantic rules for attributes.
For each production the synthesized attributes associated with its corresponding nonterminal and the inherited attributes
of its children must be defined.
If there is a rule for a certain attribute is missing, the system tries to derive a so called copy-rule.

Semantic rules are organised per production.
Semantic rules for the same production can be spread over multiple ==sem== statements.
This has the same meaning as they were defined in a single ==sem== statement.

A _fieldref_ is ==lhs== or ==loc== or a field name.
To refer to a synthesized attribute of the nonterminal associated with a production
the special fieldref ==lhs== is used together with the name of the attribute.
To refer to an inherited attribute of a child of a production the field name of the
child is used together with the attribute's name.
The special fieldref ==loc== is used to define a variable that is local to the production.
It is in the scope of all semantic rules for the production.

The expressions in semantic rules are code blocks,
i.e. Haskell expressions enclosed by ={= and =}=.
They may contains references to values of attributes and fields.
These references are all prefixed with an =@= symbol to distinguish them from Haskell identifiers.
To refer to the value of a field one uses the name of the field.
References to attributes are similar to the ones on the left-hand side of a semantic rule such as =field.attr=.
The difference is that they now refer to the synthesized attributes of the children and
the inherited attributes of the nonterminal associated with the production.
Local variables can be referenced using their name, optionally prefixed with the special =loc= field.  

Valid definitions:

<verbatim>
attr Tree
   inh gmin   :: Int
   syn min    :: Int
   syn result :: Tree
sem Tree
   | Bin  left.gmin  = { @lhs.gmin } 
     -- "left.gmin" refers to the inherited attribute "gmin"
     -- of the child "left"
   | Bin  right.gmin = { @lhs.gmin } 
     -- "@lhs.gmin" refers to the inherited attribute "gmin" 
     -- of nonterminal "Tree"
   | Bin  loc.min    = { min @left.min @right.min } 
     -- "min" is a new local variable of the constructor "Bin"

sem Tree
  | Bin  lhs.result = { Bin @left.result @right.result } 
    -- "@left.result" refers to the synthesized attribute "result" 
    -- of child "left"
  | Bin  lhs.min    = { @min }                           
    -- "@min" refers to the local variable "min"
  | Leaf lhs.result = { Leaf @lhs.gmin }                 
    -- "@lhs.gmin" refers to the inherited attribute "gmin" 
    -- of nonterminal "Tree"
  | Leaf lhs.min    = { @int }                           
    -- "@int" refers to the value of field "int" of "Leaf"</verbatim>

For the ==sem== construct there exist a number of abbreviations.
As for ==data== statements one can write attribute declarations after the name of the nonterminal.
Furthermore semantic rules for the same production can be grouped, mentioning the name of the production only once.
For example:

<verbatim>
sem Tree  
   | Bin  left.gmin  = { @lhs.gmin }
          right.gmin = { @lhs.gmin } 
          loc.min    = { min @left.min @right.min } </verbatim>

In a similar way semantic rules for the same fieldref can be grouped. For example:

<verbatim>
sem Tree
  | Bin  lhs.result = { Bin @left.result @right.result }
            .min    = { @min }                          </verbatim>

When the same semantic rule is defined for two productions of the same nonterminal they can be combined
by writing the names of both productions in front of the rule.
For example:

<verbatim>
sem Tree
  | Node1 lhs.value = { @left.value + @right.value }
  | Node2 lhs.value = { @left.value + @right.value }</verbatim>

can be abbreviated as follows:

<verbatim>
sem Tree
  | Node1 Node2 lhs.value = { @left.value + @right.value }</verbatim>

Finally the curly braces around expressions may be left out.
The layout of the code is then used to determine the end of the expression as follows.
The column of the first non-whitespace symbol after the `=' symbol is the reference column.
All subsequent lines that are indented the same or further to the right are considered to be part of the expression.
The expression ends when a line is indented less than the reference column.
An advantage of using layout is that problems with unbalanced braces are avoided.

When using polymorphic abstract syntax, the type variables often need to be constrained by the Ord class in order to put values of this type in sets or maps. Add context using:

<verbatim>
data Tree a
sem Ord {a}, Show {a} => Tree</verbatim>

It is also possible to add such a context at ==data== or ==attr== declarations.

A rule introduced by a ==sem== introduces dependencies between attributes. It is sometimes desirable to add additional dependencies between attributes. For example, when using the ==-O== option to derive a static multi-visit rule ordering, scheduling of attributes is done greedily, with as much attributes per visit as possible. By adding additional dependencies, we end up with smaller visits.

To add an additional dependency that fld1.at1 is evaluated strictly before fld2.at2, write:

<verbatim>
sem D
  | C  fld1.at1 < fld2.at2</verbatim>

You may use local attributes as well.

There are two meta-fields called ==first__== and ==last__==. When using ==@first__.x==, the first field of the alternative is substituted that has a synthesized attribute ==x==. Similarly, with ==@last__.x== the last field with a synthesized attribute ==x== is selected. At the moment, these meta-fields can only be used in right-hand sides.

There is special notation for higher-order attributes (also called nonterminal attributes). A higher-order attribute is a local attribute that acts as if it is an additional child of the production. It has either type ==D== or type ==T_D== (where ==D== is some AST declared by a ==data== declaration). For example:

<verbatim>
data D | C Int
data R | R
sem R
  | R  inst.x :: D
       inst.x = C 3</verbatim>

Now, it is as if ==x== is a child of ==R==, although the value is defined by a rule instead of obtained from the constructor. The type signature is obligatory.
You can also use the "deforested" types (T_D), and build the deforested tree yourself (using e.g. sem_C). Please note that nonterminal-names should not start with a "T_".

You need to supply inherited attributes of ==D== and can use synthesized attributes of ==D==:

<verbatim>
attr D
   inh p :: Int
   syn q :: Int
sem R
  | R  x.p = 3
       loc.z = @x.q + 1</verbatim>

Like normal children, higher-order attributes participate with copy rules. Higher-order attributes are considered as children after the normal children of a constructor, in the order of lexical appearance.

If a higher-order attribute shadows an existing child, its definition is actually a function from the semantics of the original child to the new semantics:

<verbatim>
data D1 | C1   k :: D1
data D2 | C2

sem D1 | C1  inst.k :: D2
             inst.k = \semD1 -> sem_D2_C2 ...</verbatim>

Sometimes it is needed to specify type signatures for local attributes:

<verbatim>
sem D
  | C     loc.x :: {type}</verbatim>

---+++ type

The ==type== construct is convenient notation for defining list based types.
Apart from a convenient notation the ==type== construct has effect on the code generated.
Instead of generating data constructors
_Cons_ and _Nil_ Haskell's list constructors =:= and =[]= are used.

Examples of ==type== constructs:

<verbatim>
type IntList = [ Int ]
type Trees   = [ Tree ]</verbatim>

The following other type synonyms are supported:
<verbatim>
type MbInt = maybe Int
type EIntBool = either Int Bool
type Trip = (Int, Bool, Char)
type M1 = map {String} D   -- curly braces required (key must be a haskell type)
type M2 = intmap D</verbatim>

Nonterminals are also allowed as argument:
<verbatim>
type MbExpr = maybe Expr
attr MbExpr Expr
   syn tp :: Type

sem MbExpr
  | Just     lhs.tp = @just.tp
  | Nothing  lhs.tp = undefined</verbatim>

   * A list has productions: ==Cons== with field ==hd== and field ==tl==, ==Nil== without any fields.
   * A =maybe= has productions: ==Just== with field ==just==, ==Nothing== without any fields.
   * An =either= has productions: ==Left== with field ==left==, ==Right== with field ==right==.
   * A =map= has productions: ==Entry== with field ==key==, ==val==, and ==tl==, ==Nil== without any fields.
   * A tuple has productions: ==Tuple== with fields ==x1==, ==x2==, etc..

---+++ include

Other UUAG files can be included using the following construct:

<verbatim>
include "filename.ag"</verbatim>

The filename must appear in double quotes.
The suffix of the file =.ag= or =.lag=) should not be omitted.
The file should contain valid UUAG declarations.
These statements are inlined in the place of the ==include== directive.

---+++ Code Block

A code block is a piece of Haskell code enclosed by curly braces.
There exist three kinds of code blocks: top-level, type, and expression code blocks.
A top-level code block contains Haskell declarations, such as ==import== declarations, and function and type definitions.
A name can be writen before a top-level code block.
The code blocks are sorted by their names, and appended to the code generated by the UUAG system.
A special name ==imports== is used to mark code blocks containing ==import== declarations.
These are copied to the start of the generated code, as Haskell only allows ==import== declarations at the beginning of a file.

An example of two code blocks, an import declaration and a function definition:

<verbatim>
imports
{
import List
}

quicksort
{ 
-- simple implementation of quicksort:
qsort :: Ord a => [a] -> [a]
qsort [] = []
qsort (x:xs) = let (l,r) = partition (<=x) xs 
               in qsort l ++ [x] ++ qsort r
}</verbatim>

A type code block contains a 